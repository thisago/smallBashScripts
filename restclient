#!/bin/bash

# restclient - Runs Emacs restclient.el from CLI

# Check if Emacs Daemon is running
if ! pgrep -x "emacs" >/dev/null; then
  echo "Emacs daemon is not running. Please start it first."
  exit 1
fi

file=$(realpath $1)
query="$2"
timeout="$3"
shift 2

# Set default timeout if unset, empty, not a valid integer
if [[ "$timeout" =~ ^[0-9]+$ ]]; then
  shift 1
else
  timeout=10
fi
if test -z "$file"; then
  echo "Usage: restclient <HTTP FILE> [QUERY] [TIMEOUT_SECONDS]" >&2
  exit 1
fi

# Parse overrides from multi arg `--var <KEY> <VAL>`
declare -A overrides
while [[ "$1" == --var ]]; do
  key="$2"
  val="$3"
  overrides["$key"]="$val"
  shift 3
done

elisp_override=""
for var in "${!overrides[@]}"; do
  val="${overrides[$var]}"
  esc_var=$(printf '%s' "$var" | sed 's/"/\\"/g')
  esc_val=$(printf '%s' "$val" | sed 's/"/\\"/g')
  elisp_override+="(restclient-set-var \"$esc_var\" \"$esc_val\") "
done

elisp=$(
  cat <<EOF
(progn
  (find-file "$file")
  (goto-char (point-min))
  (search-forward "$query")
  $elisp_override
  (restclient-http-send-current)
  (let ((response-buffer-name "*HTTP Response*")
        (n 0)
        (max-n (* $timeout 10))) ;; max-n: timeout in tenths of seconds
    ;; Wait/poll for buffer to appear (max timeout seconds)
    (while (and (< n max-n)
                (or (not (get-buffer response-buffer-name))
                    (= (buffer-size (get-buffer response-buffer-name)) 0)))
      (sleep-for 0.1)
      (setq n (+ n 1)))
    (let ((filebuf (find-buffer-visiting "$file")))
      (if (get-buffer response-buffer-name)
          (let ((output
                 (with-current-buffer response-buffer-name
                   (buffer-substring-no-properties (point-min) (point-max)))))
            (kill-buffer response-buffer-name)
            (when filebuf (kill-buffer filebuf))
            output)
        (when filebuf (kill-buffer filebuf))
        "ERROR: No HTTP Response buffer found"))))
EOF
)

parse_restclient_output() {
  input="$1"

  # Accumulate the body as raw text, no expansion
  local body_json=""
  declare -A headers
  local method=""
  local host=""
  local url=""
  local status_code=""
  local status_name=""
  local body_part_done=0
  while IFS= read -r line; do
    if [[ "$body_part_done" == "0" ]]; then
      if [[ "$line" =~ ^// ]]; then
        body_part_done=1
      else
        body_json+="$line"
      fi
    fi
    if [[ "$body_part_done" == "1" ]]; then
      comment="${line#// }"
      if [[ "$comment" =~ ^(GET|POST|PUT|PATCH|DELETE|OPTIONS)[[:space:]](https?://[^ ]+) ]]; then
        method="${BASH_REMATCH[1]}"
        url="${BASH_REMATCH[2]}"
        host=$(echo "$url" | awk -F/ '{print $3}')
        continue
      fi
      regex="^HTTP/[0-9]+\.[0-9]+ ([0-9]+) (.+)$"
      if [[ "$comment" =~ $regex ]]; then
        status_code="${BASH_REMATCH[1]}"
        status_name="${BASH_REMATCH[2]}"
        continue
      fi
      if [[ "$comment" == *": "* ]]; then
        k="${comment%%:*}"
        v="${comment#*: }"
        headers["$k"]="$v"
      fi
    fi
  done <<<"$input"

  # Compose jq header map builder
  headers_object="{}"
  for k in "${!headers[@]}"; do
    headers_object=$(jq \
      --arg key "$k" \
      --arg value "${headers[$k]}" \
      '.[$key] = $value' <<<"$headers_object")
  done

  jq -n \
    --arg body "$body_json" \
    --arg method "$method" \
    --arg host "$host" \
    --arg url "$url" \
    --arg status_name "$status_name" \
    --arg status_code "$status_code" \
    --argjson headers "$headers_object" \
    '{
      body: $body,
      headers: $headers,
      status: {
        code: ($status_code|tonumber),
        name: $status_name
      },
      host: $host,
      method: $method,
      url: $url
    }'
}

result=$(emacsclient --eval "$elisp" | jq -r '.')
parse_restclient_output "$result"
