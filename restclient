#!/bin/bash

# restclient - Runs Emacs restclient.el from CLI

if ! test -n "$RESTCLIENT_DIR"; then
  echo "Set RESTCLIENT_DIR in your path"
  exit 1
fi

# Check if Emacs Daemon is running
if ! pgrep -x "emacs" >/dev/null; then
  echo "Emacs daemon is not running. Please start it first."
  exit 1
fi

file="$1"
if [[ ! "$file" =~ .http$ ]]; then
  file="$file.http"
fi
if ! test -f "$file"; then
  file="$RESTCLIENT_DIR/$file"
  if ! test -f "$file"; then
    echo "Available http files:"
    cd "$RESTCLIENT_DIR"
    fd '.http$' | sed -r 's/^(.*).http$/  \1/'
    exit 1
  fi
fi

query="$2"
timeout="$3"
shift 2

# Set default timeout if unset, empty, not a valid integer
if [[ "$timeout" =~ ^[0-9]+$ ]]; then
  shift 1
else
  timeout=10
fi
if test -z "$file"; then
  echo "Usage: restclient <HTTP FILE> [QUERY] [TIMEOUT_SECONDS] [--var <NAME> <VAL> ...]" >&2
  exit 1
fi

# Parse overrides from multi arg `--var <KEY> <VAL>`
declare -A overrides
while [[ "$1" == --var ]]; do
  key="$2"
  val="$3"
  overrides["$key"]="$val"
  shift 3
done

elisp_override=""
elisp_clean=""
json_overrides="{}"
for var in "${!overrides[@]}"; do
  val="${overrides[$var]}"
  esc_var=$(printf '%s' "$var" | sed 's/"/\\"/g')
  esc_val=$(printf '%s' "$val" | sed 's/"/\\"/g')
  elisp_override+="(restclient-set-var \"$esc_var\" \"$esc_val\") "
  elisp_clean+="(restclient-remove-var \"$esc_var\") "
  json_overrides=$(jq \
    --arg var "$var" \
    --arg val "$val" \
    '.[$var] = $val' <<<"$json_overrides")
done

elisp=$(
  cat <<EOF
(progn
  (find-file "$file")
  (goto-char (point-min))
  (search-forward "$query")
  $elisp_override
  (restclient-http-send-current)
  (let ((response-buffer-name "*HTTP Response*")
        (n 0)
        (max-n (* $timeout 10))) ;; max-n: timeout in tenths of seconds
    ;; Wait/poll for buffer to appear (max timeout seconds)
    (while (and (< n max-n)
                (or (not (get-buffer response-buffer-name))
                    (= (buffer-size (get-buffer response-buffer-name)) 0)))
      (sleep-for 0.1)
      (setq n (+ n 1)))
    (let ((filebuf (find-buffer-visiting "$file")))
      (if (get-buffer response-buffer-name)
          (let ((output
                 (with-current-buffer response-buffer-name
                   (buffer-substring-no-properties (point-min) (point-max)))))
            (kill-buffer response-buffer-name)
            (when filebuf (kill-buffer filebuf))
            $elisp_clean
            output)
        (when filebuf (kill-buffer filebuf))
        "ERROR: No HTTP Response buffer found"))))
EOF
)

parse_restclient_output() {
  input="$1"

  # Accumulate the body as raw text, no expansion
  local body_json=""
  declare -A headers
  local method=""
  local host=""
  local url=""
  local status_code=""
  local status_text=""
  local body_part_done=0
  while IFS= read -r line; do
    if [[ "$body_part_done" == "0" ]]; then
      if [[ "$line" =~ ^// ]]; then
        body_part_done=1
      else
        body_json+="$line"
      fi
    fi
    if [[ "$body_part_done" == "1" ]]; then
      comment="${line#// }"
      if [[ "$comment" =~ ^(GET|POST|PUT|PATCH|DELETE|OPTIONS)[[:space:]](https?://[^ ]+) ]]; then
        method="${BASH_REMATCH[1]}"
        url="${BASH_REMATCH[2]}"
        host=$(echo "$url" | awk -F/ '{print $3}')
        continue
      fi
      regex="^HTTP/[0-9]+\.[0-9]+ ([0-9]+) (.+)$"
      if [[ "$comment" =~ $regex ]]; then
        status_code="${BASH_REMATCH[1]}"
        status_text="${BASH_REMATCH[2]}"
        continue
      fi
      if [[ "$comment" == *": "* ]]; then
        k="${comment%%:*}"
        v="${comment#*: }"
        headers["$k"]="$v"
      fi
    fi
  done <<<"$input"

  # Compose jq header map builder
  headers_object="{}"
  for k in "${!headers[@]}"; do
    headers_object=$(jq \
      --arg key "$k" \
      --arg value "${headers[$k]}" \
      '.[$key] = $value' <<<"$headers_object")
  done

  # Try to parse body as JSON
  if echo "$body_json" | jq . >/dev/null 2>&1; then
    is_body_json=true
    parsed_body=$(echo "$body_json" | jq '.')
  else
    is_body_json=false
    parsed_body=$(jq -n --arg raw "$body_json" '$raw')
  fi

  jq -n \
    --argjson body "$parsed_body" \
    --argjson isBodyJson "$is_body_json" \
    --arg method "$method" \
    --arg host "$host" \
    --arg url "$url" \
    --arg status_text "$status_text" \
    --argjson status_code "$status_code" \
    --argjson headers "$headers_object" \
    --argjson overrides "$json_overrides" \
    '{
      body: $body,
      isBodyJson: $isBodyJson,
      headers: $headers,
      status: {
        code: $status_code,
        text: $status_text
      },
      host: $host,
      method: $method,
      url: $url,
      overrides: $overrides,
    }'
}

result=$(emacsclient --eval "$elisp" | jq -r '.')
parse_restclient_output "$result"
